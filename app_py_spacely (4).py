# -*- coding: utf-8 -*-
"""APP.PY_SPACELY.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1dZbL18Fy4RfuMLLH2NmMgaAUWJzOAALK
"""

!pip install streamlit
import streamlit as st
import pandas as pd

# 1. Load DataFrame from CSV file
github_csv_url = 'https://raw.githubusercontent.com/Ertyuuu55/Spacely/main/Furniture%20(1).csv'
df = pd.read_csv(github_csv_url) # Pass the variable, not a string literal

# 2. Consolidated Prioritized Greedy Selection Function (copied from notebook)
def consolidated_prioritized_greedy_selection_with_quantities(df, budget, desired_categories_with_quantities):
    selected_items = []
    total_cost = 0.0
    selection_messages = []

    # Create a copy of the DataFrame to manage available items
    remaining_df = df.copy()

    # 1. Prioritized selection based on desired categories and quantities
    for item_request in desired_categories_with_quantities:
        category = item_request['category']
        quantity_desired = item_request['quantity']
        selected_count_for_category = 0

        if category not in df['category'].unique(): # Check if category exists in original df
            selection_messages.append(f"Warning: Desired category '{category}' is not available in our inventory.")
            continue

        category_items_initial = remaining_df[remaining_df['category'] == category].sort_values(by='price', ascending=True)

        if category_items_initial.empty:
            selection_messages.append(f"Warning: No items found for desired category '{category}' currently in stock.")
            continue

        for _ in range(quantity_desired):
            # Re-filter category items from the current remaining_df to get the cheapest available
            current_category_items = remaining_df[remaining_df['category'] == category].sort_values(by='price', ascending=True)

            if not current_category_items.empty:
                cheapest_item = current_category_items.iloc[0]
                if total_cost + cheapest_item['price'] <= budget:
                    selected_items.append(cheapest_item.to_dict())
                    total_cost += cheapest_item['price']
                    # Remove the selected item from remaining_df by its index
                    remaining_df = remaining_df.drop(cheapest_item.name)
                    selected_count_for_category += 1
                else:
                    selection_messages.append(f"Could not afford remaining {quantity_desired - selected_count_for_category} item(s) from category '{category}' (cheapest available: ${cheapest_item['price']:.2f}) within budget. Budget remaining: ${budget - total_cost:.2f}")
                    break # Break from the inner loop for this category
            else:
                selection_messages.append(f"Ran out of available items for category '{category}' before fulfilling {quantity_desired} items. Selected {selected_count_for_category}.")
                break

        if selected_count_for_category == quantity_desired:
            selection_messages.append(f"Successfully selected {quantity_desired} items for category '{category}'.")
        elif selected_count_for_category > 0:
            selection_messages.append(f"Selected {selected_count_for_category} out of {quantity_desired} desired items for category '{category}'.")

    # 2. Greedily select other cheapest items from the remaining budget and DataFrame
    selection_messages.append("Attempting to fill remaining budget with other cheapest items.")
    sorted_remaining_df = remaining_df.sort_values(by='price', ascending=True)

    for index, row in sorted_remaining_df.iterrows():
        item_price = row['price']
        if total_cost + item_price <= budget:
            selected_items.append(row.to_dict())
            total_cost += item_price
        else:
            # If adding the current item exceeds the budget, stop.
            selection_messages.append(f"Stopped greedy selection as next item (price: ${item_price:.2f}) exceeds remaining budget (${budget - total_cost:.2f}).")
            break

    if not selected_items:
        selection_messages.append("No items were selected within the budget criteria.")

    return selected_items, total_cost, selection_messages

# 3. Parsing Function
import re

def parse_user_prompt(prompt, df):
    prompt = prompt.lower()
    categories = df['category'].unique()

    #a. Budget WAJIB
    budget_match = re.search(r'(\d+)', prompt)
    if not budget_match:
        return None, None, "Budget tidak ditemukan dalam input."

    budget = float(budget_match.group(1))

    #b. Category + quantity (OPSIONAL)
    desired = []
    for cat in categories:
        cat_lower = cat.lower()
        if cat_lower in prompt:
            qty_match = re.search(rf'{cat_lower}\s*(\d+)', prompt)
            qty = int(qty_match.group(1)) if qty_match else 1
            desired.append({"category": cat, "quantity": qty})

    return budget, desired, None

# 4. Pemanggilan Output
def select_furniture_based_on_request(df, budget, requested_items):
    selected_items = []
    total_cost = 0
    messages = []

    # MODE 1: Tidak ada furniture spesifik
    if not requested_items:
        default_categories = ['table', 'sofa', 'chair', 'desk', 'bed']

        for cat in default_categories:
            cat_items = df[df['category'].str.lower() == cat].sort_values('price')
            if not cat_items.empty:
                item = cat_items.iloc[0]
                if total_cost + item['price'] <= budget:
                    selected_items.append(item.to_dict())
                    total_cost += item['price']
                else:
                    messages.append(
                        f"Budget tidak cukup untuk mengambil {cat} (harga ${item['price']:.2f})"
                    )

        messages.append("Menampilkan 1 item termurah dari setiap kategori furniture.")
        return selected_items, total_cost, messages

    # MODE 2: Ada furniture spesifik
    for req in requested_items:
        category = req['category']
        qty = req['quantity']

        cat_items = df[df['category'] == category].sort_values('price')

        if cat_items.empty:
            messages.append(f"Tidak ada item untuk kategori {category}")
            continue

        selected_qty = 0
        for _, row in cat_items.iterrows():
            if selected_qty >= qty:
                break
            if total_cost + row['price'] <= budget:
                selected_items.append(row.to_dict())
                total_cost += row['price']
                selected_qty += 1

        messages.append(
            f"Menampilkan {selected_qty} item untuk kategori '{category}'."
        )

    return selected_items, total_cost, messages

# 5. Streamlit Application UI
st.set_page_config(layout="centered", page_title="Furniture Recommender")
st.title("Furniture Recommendation System")
st.write("Enter your budget and desired furniture categories with quantities to get recommendations.")

# # Input for budget
# user_budget = st.number_input("Enter your total budget ($):", min_value=0.0, value=300.0, step=10.0)

# # Get unique categories from the DataFrame for display
# available_categories_str = ', '.join(df['category'].unique())

# # Input for categories and quantities
# user_categories_quantities_input = st.text_input(
#     f"Enter desired furniture categories (e.g., Bed, Chair:2). Options: {available_categories_str}",
#     value="Bed, Desk:5"
# )
st.header("Chat Input")

user_prompt = st.text_input(
    "Masukkan kebutuhan furniture Anda (budget WAJIB)",
    placeholder="Contoh: Budget 500, bed 2, chair"
)

# Process user categories and quantities input
user_desired_categories_with_quantities = []
if user_categories_quantities_input:
    for item_str in user_categories_quantities_input.split(','):
        item_str = item_str.strip()
        if not item_str:
            continue

        parts = item_str.split(':')
        category = parts[0].strip()
        quantity = 1 # Default quantity if not specified

        if category not in df['category'].unique():
            st.warning(f"Warning: Category '{category}' is not a valid option and will be ignored.")
            continue

        if len(parts) == 1:
            # Only category provided, use default quantity = 1
            user_desired_categories_with_quantities.append({"category": category, "quantity": quantity})
        elif len(parts) == 2:
            try:
                quantity = int(parts[1].strip())
                if quantity <= 0:
                    st.warning(f"Warning: Quantity for '{category}' must be a positive integer. Ignoring '{item_str}'.")
                    continue
                user_desired_categories_with_quantities.append({"category": category, "quantity": quantity})
            except ValueError:
                st.warning(f"Warning: Quantity for '{category}' is not a valid number and will be ignored. Please enter an integer.")
        else:
            st.warning(f"Warning: Invalid input format for '{item_str}'. Please use 'Category' or 'Category:Quantity'.")

# Button to trigger recommendations
if st.button("Generate Recommendations"):
    if not user_prompt.strip():
        st.error("Input tidak boleh kosong.")
    else:
        user_budget, user_desired_categories, error = parse_user_prompt(user_prompt, df)

        if error:
            st.error(error)
        else:
            st.markdown("""
            <style>
            .furniture-card {
                background-color: #ffffff;
                padding: 18px;
                border-radius: 14px;
                margin-bottom: 16px;
                box-shadow: 0 6px 14px rgba(0,0,0,0.08);
            }
            .furniture-title {
                font-size: 22px;
                font-weight: 600;
                margin-bottom: 8px;
            }
            .furniture-item {
                font-size: 15px;
                margin: 4px 0;
            }
            </style>
            """, unsafe_allow_html=True)

            st.subheader("Recommendation Results")

            results, total_cost, messages = select_furniture_based_on_request(
              df, user_budget, user_desired_categories
            )

            for msg in messages:
                st.info(msg)

            if results:
                result_df = pd.DataFrame(results)
                # st.dataframe(
                #     result_df[['category', 'price', 'material', 'color']]
                #     .style.format({'price': '${:.2f}'})
                # )
                st.subheader("Rekomendasi Furniture")

                for item in results:
                    st.markdown(f"""
                    <div class="furniture-card">
                        <div class="furniture-title">ðŸª‘ {item['category']}</div>
                        <div class="furniture-item"><b>Harga:</b> ${item['price']:.2f}</div>
                        <div class="furniture-item"><b>Material:</b> {item['material']}</div>
                        <div class="furniture-item"><b>Warna:</b> {item['color']}</div>
                    </div>
                    """, unsafe_allow_html=True)

                st.success(f"Total Cost: ${total_cost:.2f}")
            else:
                st.warning("Tidak ada furniture yang bisa direkomendasikan.")
